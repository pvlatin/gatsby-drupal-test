"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const crypto = require(`crypto`);

const uuidv4 = require(`uuid/v4`);

const _require = require(`graphql`),
      buildSchema = _require.buildSchema,
      printSchema = _require.printSchema;

const _require2 = require(`graphql-tools`),
      makeRemoteExecutableSchema = _require2.makeRemoteExecutableSchema,
      transformSchema = _require2.transformSchema,
      introspectSchema = _require2.introspectSchema,
      RenameTypes = _require2.RenameTypes;

const _require3 = require(`apollo-link-http`),
      createHttpLink = _require3.createHttpLink;

const fetch = require(`node-fetch`);

const invariant = require(`invariant`);

const _require4 = require(`./transforms`),
      NamespaceUnderFieldTransform = _require4.NamespaceUnderFieldTransform,
      StripNonQueryTransform = _require4.StripNonQueryTransform;

exports.sourceNodes =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
    actions,
    createNodeId,
    cache,
    store
  }, options) {
    const addThirdPartySchema = actions.addThirdPartySchema,
          createPageDependency = actions.createPageDependency,
          createNode = actions.createNode;
    const url = options.url,
          typeName = options.typeName,
          fieldName = options.fieldName,
          _options$headers = options.headers,
          headers = _options$headers === void 0 ? {} : _options$headers,
          _options$fetchOptions = options.fetchOptions,
          fetchOptions = _options$fetchOptions === void 0 ? {} : _options$fetchOptions,
          createLink = options.createLink,
          createSchema = options.createSchema,
          refetchInterval = options.refetchInterval;
    invariant(typeName && typeName.length > 0, `gatsby-source-graphql requires option \`typeName\` to be specified`);
    invariant(fieldName && fieldName.length > 0, `gatsby-source-graphql requires option \`fieldName\` to be specified`);
    invariant(url && url.length > 0 || createLink, `gatsby-source-graphql requiers either option \`url\` or \`createLink\` callback`);
    let link;

    if (createLink) {
      link = yield createLink(options);
    } else {
      link = createHttpLink({
        uri: url,
        fetch,
        headers,
        fetchOptions
      });
    }

    let introspectionSchema;

    if (createSchema) {
      introspectionSchema = yield createSchema(options);
    } else {
      const cacheKey = `gatsby-source-graphql-schema-${typeName}-${fieldName}`;
      let sdl = yield cache.get(cacheKey);

      if (!sdl) {
        introspectionSchema = yield introspectSchema(link);
        sdl = printSchema(introspectionSchema);
      } else {
        introspectionSchema = buildSchema(sdl);
      }

      yield cache.set(cacheKey, sdl);
    }

    const remoteSchema = makeRemoteExecutableSchema({
      schema: introspectionSchema,
      link
    });
    const nodeId = createNodeId(`gatsby-source-graphql-${typeName}`);
    const node = createSchemaNode({
      id: nodeId,
      typeName,
      fieldName
    });
    createNode(node);

    const resolver = (parent, args, context) => {
      createPageDependency({
        path: context.path,
        nodeId: nodeId
      });
      return {};
    };

    const schema = transformSchema(remoteSchema, [new StripNonQueryTransform(), new RenameTypes(name => `${typeName}_${name}`), new NamespaceUnderFieldTransform({
      typeName,
      fieldName,
      resolver
    })]);
    addThirdPartySchema({
      schema
    });

    if (process.env.NODE_ENV !== `production`) {
      if (refetchInterval) {
        const msRefetchInterval = refetchInterval * 1000;

        const refetcher = () => {
          createNode(createSchemaNode({
            id: nodeId,
            typeName,
            fieldName
          }));
          setTimeout(refetcher, msRefetchInterval);
        };

        setTimeout(refetcher, msRefetchInterval);
      }
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function createSchemaNode({
  id,
  typeName,
  fieldName
}) {
  const nodeContent = uuidv4();
  const nodeContentDigest = crypto.createHash(`md5`).update(nodeContent).digest(`hex`);
  return {
    id,
    typeName: typeName,
    fieldName: fieldName,
    parent: null,
    children: [],
    internal: {
      type: `GraphQLSource`,
      contentDigest: nodeContentDigest,
      ignoreType: true
    }
  };
}